#Plot helper functions
set verbose off
function matrix MatOrderDist (list ls, list lsB[null])
    #A function to create data for order stats boxplots (cross-section)
    scalar two = 0 #no
    scalar entries = nelem(ls)
    if exists(lsB) 
        if nelem(lsB)==entries
            two = 1 #yes
        endif 
    endif
    strings coln = array(6)
    coln[1] = "min"
    coln[2] = "lq"
    coln[3] = "med"
    coln[4] = "uq"
    coln[5] = "max"
    coln[6] = "avg"

    if two
        matrix to_plot = zeros(entries,12)
        strings colnf = array(12)
        loop i=1..12
            colnf[i]=coln[i]
            colnf[i+1]=coln[i]
            i+=1
        endloop
    else
        matrix to_plot = zeros(entries,6)
        strings colnf = array(6)	
        loop i=1..6
            colnf[i]=coln[i]
        endloop
    endif
    colnames(to_plot,colnf)

    scalar r = 0
    scalar offset = 0
    if two
        offset = 1
    endif
    loop foreach item ls -q
        r+=1	
        to_plot[r,1] = min($item)
        to_plot[r+offset*r,2] = quantile($item,.25)
        to_plot[r+offset*r,3] = quantile($item,.5)
        to_plot[r+offset*r,4] = quantile($item,.75)
        to_plot[r+offset*r,5] = max($item)
        to_plot[r+offset*r,6] = mean($item)
    endloop

	if two
	    loop foreach item lsB -q
            r+=1	
            to_plot[r+offset*(r-1),1] = min($item)
            to_plot[r+offset*(r-1),2] = quantile($item,.25)
            to_plot[r+offset*(r-1),3] = quantile($item,.5)
            to_plot[r+offset*(r-1),4] = quantile($item,.75)
            to_plot[r+offset*(r-1),5] = max($item)
            to_plot[r+offset*(r-1),6] = mean($item)
        endloop
	endif
    #boxplot --matrix=to_plot --output=display {set title "Cross-Section Distribution of Summary Statistics (Original Programme)"; } 
    return to_plot
end function

function matrices MSER5 (series ts)
    matrices ms=null
    matrix temp = {ts}
    scalar batch=0
    scalar count=0		
    scalar len = rows(temp)
    matrix MSER5 = zeros(int((len+4)/5),2) #for 5 batches. the first point of the batch refers to the i*5 in the original time series. The x-key is the time, the y-key the mser-5.
    matrix batch5 = MSER5		
    strings MSER5names = array(2)
    strings batch5names = array(2)
    MSER5names[1] = "x"
    MSER5names[2] = "MSER5"
    batch5names[1] = "x"
    batch5names[2] = "batch_mean_5"
    colnames(MSER5,MSER5names)
    colnames(batch5,batch5names)
    #Create batch and mser 5 data.
    scalar n_MSER = rows(batch5)
    scalar indx = n_MSER
    scalar running_agg = 0
    #	scalar batch_idx = 1 #batch number from back
    loop i=0..len-1			
        batch += temp[len-i]
        count += 1
        if count==5 || i==len-1 #at end
            batch5[indx,1] = len-i + int(count/2)
            MSER5[indx,1]=batch5[indx,1]
            batch5[indx,2] = batch/count #batch mean.

            #calc MSER5			
            running_agg+=batch5[indx,2]
            scalar running_avg=batch5[indx,2]/(n_MSER-indx+1)			
            loop b=indx..n_MSER --quiet #for each batch in the truncated series
                MSER5[indx,2]+=( batch5[b,2]-running_avg )*( batch5[b,2]-running_avg )
            endloop
            MSER5[indx,2] /= (n_MSER-indx+1)*(n_MSER-indx+1)
            #reset
            batch = 0
            count = 0

            #advance
            indx -= 1 
            #			batch_idx += 1

			
        endif
    endloop
    MSER5[n_MSER,2]=NA #reset last value, which is an artifact "0"
    ms+=batch5
    ms+=MSER5
    return ms
end function

function matrices series_to_matrices(list ls "input")
    matrices M = null
    #loop foreach l ls
    #    matrix temp = l
    #colnames(temp,varname(l))
    loop s=1..nelem(ls)
        matrix temp = ls[s]
        colnames(temp,varname(ls[s]))
        M += temp
    endloop
    return M
end function

function bundle series_to_bundle(list ls[null], series obskey[null], matrices ms[null])
    #transform series in bundle of two matrices, the key and the data
    matrices ms_dat = null
    matrices ms_obs = null

    if exists(ls)
        if nelem(ls)>0
            loop i=1..nelem(ls) --quiet
                matrix m_dat = {ls[i]}
                colnames(m_dat,varname(ls[i]))    
                ms_dat += m_dat
            endloop	

            if exists(obskey)==0
                series obskey = obs
            endif
            matrix m_obs = {obskey}
            colnames(m_obs,varname(obskey))
            ms_obs += m_obs #wee need the matrices format
        endif
    endif


    if exists(ms)
        loop i=1..nelem(ms) --quiet
            matrix m_dat = ms[i][,2]
            colnames(m_dat,colname(ms[i],2))    
            ms_dat += m_dat

            matrix m_obs = ms[i][,1]
            colnames(m_obs,colname(ms[i],1))
            ms_obs += m_obs #wee need2 the matrices format
        endloop	
    endif


    bundle b_dat = null
    b_dat.data = ms_dat
    b_dat.key = ms_obs
    return b_dat
end function

function string data_to_temp(matrices Ms, 
      matrices ObsK[null] "x-Keys", scalar stringstream[0:1:1] "If 1, everything is written to a string and returned, instead")
    # write data block, for each matrix a single block.
    # use the matrix column-heads as label

    #print tmpfile
    #outfile tmpfile --write 
    #outfile --close
    #gnuplot --input=@tmpfile
    scalar n = nelem(Ms)
    scalar singleK = 0
    if exists(ObsK)
        if nelem(ObsK)==1
            singleK = 1 #universal key, but provided from outside
        elif nelem(ObsK)<nelem(Ms) #number of keys does not match number of datafiles
            return "ERROR" #better way?	
        endif
    else
        singleK = 1 #DANGEROUS! PRESUMES SINGLE KEY!
        matrices ObsK = null
        matrix temp = zeros(rows(Ms[1]),1)
        loop i=1..rows(Ms[1])
            temp[i,1]=i
        endloop
        colnames(temp, "x")
        ObsK += temp 
    endif
    #Note: It is not tested if the data input has the same length, which should be the case if there is a single key.
	
    #either write data to a file or buffer it and return the string.
    if (stringstream == 0)
        string tmpfile = sprintf("%s/tmp_data.dat", $dotdir)
        outfile @tmpfile --write --quiet
    else
        outfile mybuff --buffer --quiet
    endif
    set warnings off
    loop f=1..n -q ##loop matrices 
        scalar cMf = cols(Ms[f])
        scalar rMf = rows(Ms[f])
        loop r=0..rMf  -q #loop rows, 0 for columnhead
            loop c=0..cMf  -q #loop columns
                if r==0 #print column header
                    if c==0
                        if singleK# == 1
                            printf "%s ", colname(ObsK[1], 1)
                        else
                            printf "%s ", colname(ObsK[f], 1)
                        endif
                    else                        
                        printf "%s ", colname(Ms[f], c)
                    endif                    
                else
                    if c==0
                        if singleK# == 1
                            printf "%d ",ObsK[1][r,1]
                        else
                            printf "%d ",ObsK[f][r,1]
                        endif
                    else                        
                        printf "%g ",Ms[f][r,c]
                    endif                    
                endif                            
            endloop
            printf "\n" #new row
        endloop
        printf "\n\n" #two free lines -- new index block
    endloop
    outfile --close
    set warnings on
    if (stringstream==0) 
        return tmpfile   
    else
        return mybuff
    endif
end function


